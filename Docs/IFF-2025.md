IFF-2025 Specification
======================

### Interchange File Format for modern computing

 

 

1. Introduction
---------------

 

IFF-2025 is a data container format designed to provide a flexible and
extensible framework for embedding and transporting diverse data structures,
including multimedia content, AI models, archives, and custom formats. Unlike
traditional file formats that impose rigid structures, IFF-2025 emphasizes
forward compatibility, parsing safety, and adaptability to modern computing
environments. The format's core principle revolves around self-describing
chunks: each data segment is prefixed with an identifier (tag) and a length
indicator (size), enabling parsers to safely skip unrecognized or irrelevant
content without compromising the integrity of the overall structure.

Originally developed by Electronic Arts (EA) in 1985 for the Amiga platform as
the Interchange File Format (IFF-85), the format was tailored for multimedia
interchange on resource-constrained systems. IFF-85 introduced hierarchical
nesting, shared properties, and container types. Most of the advanced features
were never fully utilized and derived formats ended up being reduced versions of
the original IFF. However, limitations such as fixed 32-bit sizes (capping data
at approximately 2 or 4 GB), mandatory big-endian encoding, and lack of support
for streaming hindered its adoption in contemporary applications.

IFF-2025 represents a modern evolution of IFF-85, preserving its foundational
concepts while incorporating enhancements to address these limitations. Key
improvements include support for variable-length tags and sizes, configurable
endianness, signed/unsigned integers, progressive (streaming) modes, sharding
for fragmented data, and scoped directives for runtime configuration. These
features enable efficient handling of large-scale data sets, real-time
streaming, and heterogeneous content aggregation, making IFF-2025 suitable for
use cases in multimedia processing, large AI data interchange, archival systems,
and distributed computing.

Backward compatibility with IFF-85 is maintained where feasible: by default,
IFF-2025 adheres to IFF-85 rules (e.g., 4-byte uppercase ASCII tags, 32-bit
big-endian sizes, and blobbed mode). Deviations are introduced via explicit
directives, ensuring that legacy parsers can process compatible subsets without
errors. This "power with control" philosophy prevents parsing ambiguities or
security vulnerabilities, such as buffer overflows, by enforcing scoped limits
and validation rules.

This specification outlines the format's structure, core components, parsing
models, configuration mechanisms, and implementation guidelines. It is intended
for developers implementing parsers, writers, validators, and related tools.
While high-level pseudocode and examples are provided, detailed implementation
specifics (e.g., internal data structures for scope management) are deferred to
reference implementations. The focus here is on normative format rules,
behavioral semantics, and interoperability requirements.

 

 

2. Summary of Evolution: From IFF-85 to IFF-2025
------------------------------------------------

 

To contextualize IFF-2025, this section provides a concise overview of its
heritage and advancements.

 

### 2.1 IFF-85 Overview

-   **Core Features**: Fixed 4-byte uppercase ASCII tags, 32-bit big-endian
    sizes, even-byte padding for alignment. Primary container types include FORM
    (typed single chunk), LIST (grouping with shared properties), CAT
    (concatenation of similar items), and PROP (shared properties applicable to
    subsequent items in a CAT or LIST, but restricted to appear before FORMs).

-   **Reserved Tags**: FOR1 through FOR9, CAT1 through CAT9, LIS1 through LIS9
    and 'JJJJ'. Chunk versioning via last letter override. (CMAP would reserve
    CMA1 through CMA9)

-   **Standard Properties in LIST**: Hardware-specific tags such as OPGM
    (original program), OCPU (original CPU), OCMP (original compiler), OSN
    (original serial number), and UNAM (user name).

-   **Applications**: Primarily Amiga multimedia, including ILBM (InterLeaved
    BitMap images), 8SVX (8-bit sampled voice audio), and SMUS (simple music)
    and professional 3D Rendering software.

-   **Strengths**: Self-describing structure enables skippable unknown chunks;
    hierarchical nesting supports complex data organization.

-   **Limitations**: Fixed size constraints limit scalability; no native support
    for streaming; big-endian encoding in an era of endian wars; potential for
    uncontrolled deep nesting; hardware-specific properties reduce portability;
    restrictive PROP placement limits flexibility.

 

### 2.2 Derivative Formats (e.g., RIFF)

-   **Adaptations**: Microsoft's Resource Interchange File Format (RIFF) adopted
    a little-endian variant, simplifying the structure by removing CAT and PROP
    containers and enforcing stricter nesting rules. Used in formats like WAV
    (audio), AVI (video), and WebP (images).

-   **Trade-offs**: Enhanced simplicity for PC environments but introduced
    redundancy in large files (e.g., repeated headers) and reduced flexibility
    for heterogeneous or shared data, switched to little endian for no practical
    reason leaving a tormented legacy behind.

 

### 2.3 IFF-2025 Advancements

IFF-2025 builds upon IFF-85 by restoring its original flexibility while
introducing modern controls:

-   **Variable Tags**: Configurable lengths of 4, 8, or 16 bytes; case-sensitive
    (e.g., 'ILBM' ≠ 'ilbm') to support namespaces and avoid collisions.

-   **Variable Sizes**: 16-bit, 32-bit, or 64-bit integers; configurable as
    signed/unsigned and big-endian/little-endian (to appease the spec flipping
    actors).

-   **Operating Modes**: Blobbed (fully sized, default) for static files;
    progressive (END-terminated) for streaming and append-only scenarios.

-   **Sharding**: Support for data continuation across fragments using filler
    directives, enabling efficient handling of large or distributed data.

-   **Scoped Directives**: Use of ' IFF' chunks for runtime configuration
    changes, with inheritance and guards to maintain safety.

-   **Released Reservations**: Previously reserved tags (e.g., FOR1-FOR9) are
    now available for custom use.

-   **Discontinued Elements**: Hardware-specific standard LIST properties (OPGM,
    OCPU, etc.) are removed to prioritize flexibility and cross-platform
    compatibility.

-   **Discontinued Versioning via Chunk ID override**: Versioning to be handled
    in data sections.

-   **Enhanced PROP Handling**: Multiple PROPs in LIST containers allow layered
    overrides (last-wins semantics); PROPs can appear anywhere in a LIST
    (relaxing IFF-85's before-FORM restriction), applying updates to subsequent
    FORMs or nested containers for phased property application; no nesting of
    containers within PROPs to enforce flatness.

-   **Validation and Safety**: Type enforcement in containers; scoped limits
    prevent overflows; directives are guarded against violating parent
    constraints.

In essence, IFF-2025 revives the elegance of IFF-85, mitigates the rigidity of
derivatives like RIFF, and equips the format for 2025-era challenges in data
interchange, including petabyte-scale archives and real-time AI model streaming.

 

 

3. Fundamental Types: Tags and Sizes
------------------------------------

 

IFF-2025 relies on two primitive types for self-description: tags (identifiers)
and sizes (length indicators). These are configurable via directives but default
to IFF-85-compatible settings for interoperability.

 

### 3.1 Tags

Represent the keying part of a Chunk and the literal keywords for container
variants and types.

-   **Definition**: A fixed-length sequence of bytes serving as a unique
    identifier for chunks or directives. Configurable lengths: 4 bytes
    (default), 8 bytes, or 16 bytes.

-   **Encoding**: ASCII characters, fully case-sensitive. Shorter identifiers
    are padded with spaces (' ') to reach the required length.

    -   **Data Tags** (IFF_TAG_TYPE_TAG): Left-aligned and right-padded (e.g.,
        'FORM' becomes 'FORM ' in 8-byte mode).

    -   **Directive Tags** (IFF_TAG_TYPE_DIRECTIVE): Right-aligned and
        left-padded (e.g., ' IFF' becomes ' IFF' in 8-byte mode).

-   **Properties**:

    -   Endian-invariant: Byte order is not affected by endianness
        configurations (tags are always read as raw byte sequences, not shoved
        into numeric types).

    -   Canonical Form: Tags are normalized for comparison and hashing to ensure
        interoperability across different lengths (see Section 10).

-   **Comparison and Hashing**: Lexicographical comparison after
    canonicalization (prioritizing type, then content). When stored in
    dictionaries or stack frames, Hashing algorithms (e.g., FNV-1a) should
    operate on the canonical form.

 

### 3.2 Sizes

-   **Definition**: An integer value indicating the length of the subsequent
    data payload (excluding the tag and size fields themselves).

-   **Length Options**: 2 bytes (16-bit), 4 bytes (32-bit, default), or 8 bytes
    (64-bit).

-   **Encoding Options**: Big-endian (default) or little-endian (not
    recommended); signed (default) or unsigned.

-   **Maximum Values**: Dependent on configuration (e.g., 64-bit unsigned
    supports up to 18 exabytes); practical implementations could impose
    application-specific caps to prevent resource exhaustion.

-   **Padding**: Optional even-byte alignment after data (default: enabled);
    configurable via directives.

 

 

4. Core Components: Containers and Chunks
-----------------------------------------

 

IFF-2025 data is composed of a sequence of components, categorized as either
containers (composite structures that embed other components) or chunks (atomic
units). The term "chunk" originates from IFF-85 and encompasses both data
properties and directives in IFF-2025.

-   **General Chunk Structure**: [Tag] [Size] [byte data] [Optional Padding]

    -   **Data Properties**: Atomic content holders for user-defined data.

    -   **Directives**: Control instructions for the parser.

-   **General Container Structure**: [(Variant) Tag] [Size (required in blobbed
    mode, absent in progressive mode)] [(Type) Tag] [nested sub-Components or
    chunks] [Optional Padding]

    -   Containers support nesting, with directives allowable at any level for
        dynamic configuration.

    -   Note: In progressive mode, the absence of the size field avoids the need
        for back-patching lengths, facilitating streaming; termination is
        handled via ' END' directives. Parsers detect mode via scope flags and
        expect sizes accordingly.

     

     

### 4.1 Chunks in Detail

Chunks are the atomic building blocks, divided into data properties and
directives

 

### 4.1.1 Data Properties

-   **Structure**: Non-directive tag + Size + Arbitrary byte data + Optional
    padding.

-   **Purpose**: Store metadata, content, or custom payloads (e.g., 'BMHD' for
    bitmap headers, 'BODY' for raw pixel or audio data).

-   **Constraints**: Data properties appear only within FORM or PROP containers;
    they are not permitted directly in LIST or CAT.

 

### 4.1.2 Directives

EA IFF 85 forbids Type IDs to contain blank characters before printable, thus
directives are all starting by blank space.

-   **Structure**: Directive tag + Size + Directive-specific data (or
    END-terminated in progressive modes).

-   **Currently defined Directive Tags**:

    -   ' IFF': Configuration header for scope updates (detailed in Section 8).

    -   ' END': Container terminator in progressive mode (size must be 0, no
        data).

    -   ' ' (all spaces, length-dependent): Filler (padding) or shard (data
        continuation), based on structuring flags.

-   **Placement and Evaluation**: Directives can roam within containers and are
    evaluated in the current scope, allowing fine-grained control without global
    side effects.

 

### 4.2. Containers in Detail

Containers provide hierarchical organization, with a variant tag indicating the
container type, a size field (required in blobbed mode, absent in progressive
mode), and a type tag for content validation.

-   **Type Tag Semantics**:

    -   For FORM containers: Must be a specific, non-blank tag (e.g., 'ILBM');
        blank '    ' is not permitted, as composition is achieved through
        natural nesting of FORMs.

    -   For LIST and CAT containers: If set to all spaces ('    '), no type
        validation is enforced, permitting heterogeneous sub-components. If
        specified (e.g., 'ILBM'), sub-FORMs must match the type; validation is
        inherited through nesting.

    -   For PROP containers: If set to all spaces ('    '), acts as a wildcard,
        indicating that the enclosed data properties apply to any FORM type
        within the enclosing LIST. If specified, properties apply only to
        matching FORM types.

This restriction on blank types for FORM ensures type safety for single-unit
containers, while LIST and CAT leverage blanks for flexibility in grouping and
concatenation. PROP wildcards enhance support for heterogeneous LISTs by
allowing global shared properties and offer a replacement for the discontinued
base list properties.

 

### 4.2.1 FORM Container

-   **Structure**: 'FORM' variant tag + [Size (blobbed only)] + Type tag
    (non-blank) + Sequence of sub-components (data properties, directives, or
    nested containers: FORM, CAT, LIST).

-   **Purpose**: Encapsulates a typed group of related data (e.g., an image with
    headers and body). Hierarchical composition is achieved by nesting FORMs or
    other containers.

-   **IFF-2025 Enhancements**: Supports progressive mode for streaming;
    directives can modify parsing within the FORM.

-   **Validation**: Type tag must be specified and non-blank; parsers MUST
    reject blank types for FORM to enforce typing. No direct PROPs allowed (use
    LIST for shared properties). FORM naturally nests into heterogeneous trees.

 

### 4.2.2 CAT Container

-   **Structure**: 'CAT ' variant tag + [Size (blobbed only)] + Type tag +
    Sequence of nested containers (FORM, CAT, LIST) interspersed with
    directives.

-   **Purpose**: Concatenates multiple items of heterogeneous types (if type tag
    is '    ') or homogeneous if a type tag is specified, supporting deeper
    nesting for complex aggregations.

-   **IFF-2025 Enhancements**: Directives can intersperse nested containers for
    dynamic adjustments, such as endianness switches mid-stream; nesting of LIST
    allows indirect shared properties.

-   **Validation**: If type tag is non-blank, all sub-FORMs MUST match in strict
    mode; blank allows any. No direct data properties or PROPs allowed.

 

### 4.2.3 LIST and PROP Containers

-   **LIST Structure**: 'LIST' variant tag + [Size (blobbed only)] + Type tag +
    Interleaved sequence of PROPs, directives, and nested containers (FORMs,
    CATs, LISTs).

    -   Multiple PROPs allow override layering (last PROP wins for conflicting
        properties); PROPs can appear at any position, updating shared
        properties for subsequent components.

    -   Purpose: Groups heterogeneous items with phased defaults (e.g., a LIST
        containing mixed ILBM images and 8SVX audio, with PROPs applying changes
        mid-sequence). Blank type tag permits any sub-FORM types. No direct data
        properties allowed, these must be wrapped in a FORM.

    -   **Validation**: If type tag is non-blank, all sub-FORMs MUST match in
        strict mode; blank allows any. No direct data properties or PROPs
        allowed.

-   **PROP Structure**: 'PROP' variant tag + [Size (blobbed only)] + Type tag +
    Flat sequence of data properties (interspersed with directives).

    -   Constraints: No nested containers; directives permitted but scoped
        locally.

    -   Purpose: Defines or updates shared properties that apply to subsequent
        data in the enclosing LIST. If type tag is '    ', properties are
        wildcard-applicable to any FORM type in the LIST; otherwise,
        type-specific.

    -   Wildcard Semantics: In heterogeneous LISTs (blank type), wildcard PROPs
        provide global defaults, while type-specific PROPs override for matching
        FORMs.

    -   ‘PROP’ units use pull not push semantics. Unless the decoder for a
        specific format explicitly requests for a data property, no extraneous
        or unrequested data should be injected in the decoder contexts.

     

**ASCII Diagram (LIST with Interleaved PROPs)**:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+----------------------------------+
| LIST |  [size (blobbed)]  |      | // Blank type: heterogeneous
+----------------------------------+
 +--------------------------------+
 | PROP | [size (blobbed)] |      |  // Initial wildcard PROP
 +--------------------------------+
  +------------------------------+
  | CMAP | size | global palette |
  +------------------------------+
 +--------------------------------+
 | FORM | [size (blobbed)] | ILBM |  // Uses initial PROP
 +--------------------------------+
  +------------------------------+
  | BODY | [size] | [image data] |
  +------------------------------+
 +--------------------------------+
 | PROP | [size (blobbed)] | ILBM |  // Interleaved override for ILBM
 +--------------------------------+
  +------------------------------+
  | BMHD | size | updated header |
  +------------------------------+
 +--------------------------------+
 | FORM | [size (blobbed)] | ILBM |  // Uses updated PROP
 +--------------------------------+
  +------------------------------+
  | BODY | [size] | [image data] |
  +------------------------------+
 +--------------------------------+
 | FORM | [size (blobbed)] | 8SVX |  // Could access PROP but 8SVX doesn't need
 +--------------------------------+
  +------------------------------+
  | BODY | [size] | [audio data] |
  +------------------------------+
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

 

5. Scope Management
-------------------

 

Scopes provide a mechanism for managing configuration states and resource
limits, implemented via a stack or dictionary-like structure (non-normative;
parsers may vary).

-   **Scope Stack**: Pushed on container entry, popped on exit.

-   **Scope Entry Contents**: Configuration flags (from directives) + Remaining
    byte limit (derived from size or inherited from parent) + Type validation
    rules (inherited from container type tag) + Shared property map (updated by
    PROPs).

-   **Inheritance Rules**: Child scopes inherit parent flags, limits, type
    validation, and property maps; updates via directives or PROPs affect only
    the current and descendant scopes.

-   **Guards and Safety**: Changes cannot violate parent constraints (e.g., no
    extension beyond parent remaining bytes); type validation enforces FORM type
    specificity and PROP applicability.

-   **PROP-Specific Scopes**: When a PROP is encountered, its properties are
    merged into the current scope's property map (with overrides); effects apply
    to subsequent components in the LIST. This enables phased updates without
    position-based validation.

-   **Depth Considerations**: No fixed limit specified; parsers should handle
    reasonable depths and guard against excessive nesting to mitigate misuse.

 

 

6. Sharding
-----------

 

Sharding allows fragmentation of large Data Properties so their decoding can
proceed in parallel with parsing. Sharding is one of the IFF-2025 enhancements
to support streaming friendly formats.

 

### 6.1 Sharding and Filler Directives

-   **' ' Directive Tag**: All-spaces tag, length-dependent (e.g., ' ' for 4
    bytes).

-   **Filler Mode** (Structuring Bit 1 = 0, default): Skipped as padding; no
    impact on data.

-   **Sharding Mode** (Structuring Bit 1 = 1): Appends data to the preceding
    chunk, enabling seamless continuation (e.g., for network-transmitted
    packets/fragments/frames).

-   **Constraints**: Must follow a valid chunk; invalid as the first component
    or after container closure.

-   **Mode Independence**: Compatible with both blobbed and progressive parsing.

 

 

7. Parsing Models
-----------------

 

IFF-2025 being a superset of IFF-85, allows a complete fallback to the old mode.
A file or stream starting by one of the 3 root containers (CAT/LIST/FORM)
implies clean IFF-85 parsing mode. See Section 9 for more info.

IFF-85 mode can also be entered via directive processing, either as root element
or locally within a container. It must be stressed that once in IFF-85 mode,
none of the enhancements will be available. If the IFF-85 mode switch happened
inside of a container scope, then its effects will terminate with the
aforementioned scope.

 

 

8. Configuration Directive: ' IFF'
----------------------------------

 

The ' IFF' directive enables scoped modifications to parsing rules, ensuring
controlled extensibility.

-   **Structure**: ' IFF' tag + Size + Version (2 byte) + Revision (2 byte) +
    Flags (8 bytes).

-   **Version Field**: Fixed at 40 (2025 - 1985 = 40).

-   **Revision Field**: Starts at 0; used for minor patches without version
    bumps.

-   **Flags**: 64-bit bitfield (see Appendix A for detailed breakdown).

-   **Defaults**: Match IFF-85 (32-bit big-endian signed sizes, 4-byte tags,
    blobbed mode, padding enabled).

-   **Application Guards**: Rejected if changes exceed parent limits or create
    invalid states; effects are immediate for subsequent reads. Does not affect
    type tag semantics, which are fixed per container.

 

**ASCII Diagram**:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+----------+----------+------------+--------+--------------------+
| ' IFF'   | Size=10  | Version=40 | Rev=0  | Flags (8 bytes)    |
+----------+----------+------------+--------+--------------------+
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

### 8.1 Version

A version of 0 turns to IFF-85 clean. It constitutes a validation error to have
any other value set, except for the revision, which can be optionally set but
has no direct side effects.

IFF-2025 is mapped to version 40. No other versions are documented in this
specification.



### 8.2 Flags Bitfield

-   **Sizing (Bits 0-7)**: Controls size field length; from 16-bit for embedded
    systems to 64-bit for large data.

-   **Tag Sizing (Bits 8-15)**: Longer tags reduce collision risk in large
    namespaces.

-   **Operating (Bits 16-23)**: Progressive mode requires ' END' for all
    containers.

-   **Encoding (Bits 24-31)**: Reserved for compressed or encoded payloads.

-   **Typing (Bits 32-39)**: Unsigned for maximum range; LE sizes supported.

-   **Structuring (Bits 40-47)**: No-padding for compact streams; sharding for
    lower latency.

-   **Reserved (Bits 48-63)**: Future-proofing; Not currently in use in V40.

 

**Bit Layout ASCII Diagram**:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Sizing block
------------
00000000 : Base IFF 85, 32 bit sizes
00000001 : 64 bit sizes
11111111 : 16 bit sizes

Tag Sizing block
----------------
00000000 : Base IFF 85 mode, 4 bytes tag sizes
00000001 : 8 bytes tag sizes
00000002 : 16 bytes tag sizes

Operating modes block
---------------------
00000000 : Base IFF 85, Blobbed mode
00000001 : Progressive mode

Encoding modes block
--------------------
00000000 : Base IFF 85 mode, BASE256 (raw binary)

Typing Flags block (Affecting sizes only)
-----------------------------------------
00000000 : Base IFF 85 mode, Big Endian and Signed
00000001 : Switch to unsigned 
00000010 : Switch to little endian

Structuring Flags block
-----------------------
00000000 : Base IFF 85 mode, padding on and blank chunk type skipped
00000001 : Disable padding byte
00000010 : Enable sharding via blank chunk type
00000100 : Enforce CAT/LIST declared type vs contained FORM type validation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

### 8.3 Semantics and Guards (Expanded)

-   **Immediate Effect**: Post-directive sizes/tags use new rules.

-   **Guard Examples**: Child size exceeding remaining scope size.

-   **Error Handling**: On invalid directive, halt parsing and report error
    (e.g., "Invalid configuration change").

-   **Type Independence**: Flags do not alter type tag validation or chunk data.

 

### 8.4 Blobbed Mode

-   **Characteristics**: All components include explicit sizes; parsing proceeds
    by reading tag, size, then exactly 'size' bytes of data/sub-components.

-   **Validation**: Track consumed bytes against declared size; error on overrun
    or underrun.

-   **Padding**: Applied post-data for alignment (configurable).

-   **Use Cases**: Static files where total length is known upfront.

 

### 8.5 Progressive Mode

-   **Characteristics**: Containers lack sizes; terminated explicitly by ' END'
    directives. Parsers must detect the absence of size based on current mode
    flags.

-   **Purpose**: Enables streaming and append-only workflows (e.g., live data
    generation without precomputing lengths).

-   **Bounding**: Limited by parent scope's remaining bytes (root may be
    unbounded, but practical parsers should impose timeouts or caps).

-   **Validation**: Require matching ' END' for each open container; mismatch
    triggers error. Type validation occurs dynamically as sub-components are
    encountered;

-   **Padding**: Applied post-data for alignment (configurable).

-   **Use Cases**: Ideal for fragmented streams, where shards bridge across
    transmission boundaries or enable progressive decoding.

 

#### 8.6.1 ' END' Directive Details

-   **Structure**: ' END' tag + Size (must be 0) + No data.

-   **Semantics**: Closes the innermost open container; only valid in
    progressive mode.

 

 

9. Parser Bootstrapping notes
-----------------------------

 

Because a parser needs a starting mode to operate, and given the requirement to
stay compatible with IFF-85, an IFF-2025 compliant parser bootstraps in pseudo
IFF-85 mode, that is, an IFF-2025 version with every extension turned off. An
equivalent ‘ IFF’ directive of [0x0028][0x0000][0x0000000000000000] this
bootstrapping configuration is then either promoted to IFF-85 clean
[0x0000][0x0000][0x0000000000000000] if the first encountered Tag is one of
CAT/LIST/FORM, or overridden by a proper ‘ IFF’ directive.

An eventual ‘ IFF’ directive received before the root container sets a global
scope. A Blobbed mode would for instance impose a physical limit to the
potential file length.

 

### 9.1 Example effects

The following section illustrates some of the potential bootstrapping modes and
effects

 

### 9.1.1 Clean IFF 85 via IFF Directive

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 IFF [size] {[0][0][0]}       // Clean IFF 85 start via explicit switch
FORM [size] ANIM
  BMHD [size] [header]
  CMAP [size] [palette]
   IFF { .. } <----------------- ERROR, invalid TAG
  BODY [size] [pixels]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

### 9.1.2 IFF 85 compatible settings via IFF Directive

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 IFF [size] {[40][0][0]}      // IFF 85 alike configuration
FORM [size] ANIM              // Size is setting a boundary. Even switching to
  BMHD [size] [header]        //  64 bits, this boundary cannot be exceeded
  CMAP [size] [palette]
   IFF { .. } <----------------- Further mode switch possible with limitations
  BODY [size] [pixels]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

### 9.1.3 Clean IFF 85 via first Tag rule

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
FORM [size] ANIM              // First Tag is a FORM, promoting config to IFF 85
  BMHD [size] [header]
  CMAP [size] [palette]
   IFF { .. } <----------------- ERROR, invalid TAG
  BODY [size] [pixels]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

### 9.1.4 Temporary IFF 85 compatible settings in a scope

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 IFF [size] {[40][0][0]}      // IFF 85 alike configuration
CAT  [size] AMIM 
  FORM [size] ANIM            
    BMHD [size] [header]      
    CMAP [size] [palette]
     IFF [size] {[0][0][0]} <--- Locks to IFF 85, no further directives allowed
    BODY [size] [pixels]
  FORM [size] ANIM          <--- A new FORM constitutes a new scope. Inheriting 
    BMHD [size] [header]           the parent configuration [40][0][0]
     IFF [size] {[40][0][0]} <-- Further mode switch possible with limitations
    CMAP [size] [palette]
     IFF [size] {[40][0][0]} <-- Further mode switch possible with limitations
    BODY [size] [pixels]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

### 9.1.5 Implicit IFF 85 mode locking

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CAT  [size] AMIM              // First Tag is a FORM, promoting config to IFF 85
  FORM [size] ANIM          <--- A new FORM constitutes a new scope. Inheriting 
    BMHD [size] [header]           the parent configuration as [0][0][0]
    CMAP [size] [palette]          still no directives allowed anymore 
    BODY [size] [pixels]
  FORM [size] ANIM          
    BMHD [size] [header]           
    CMAP [size] [palette]
    BODY [size] [pixels]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

 

10. Illustrative Diagrams and Examples
--------------------------------------

 

This section provides visual and code-like examples to demonstrate key concepts,
incorporating updated type tag rules and interleaved PROPs.

### 10.1 Basic Chunk Diagram

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+------+------+------+
| TAG  | SIZE | DATA |
+------+------+------+
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

### 10.2 Nested FORM Example (Blobbed Mode)

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
FORM [size] ANIM
  FORM [size] ILBM
    BMHD [size] [header]
    CMAP [size] [palette]
    BODY [size] [pixels]
  FORM [size] ILBM
    BMHD [size] [header]
    CMAP [size] [palette]
    BODY [size] [pixels]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Note: No blank type for FORM; nesting provides composition.

 

### 10.3 Heterogeneous LIST Example (Progressive Mode)

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
LIST                             // Absent size, type='    ' (heterogeneous)
  PROP                           // Wildcard, absent size
    CMAP [size] [shared palette]
  ' END' [0]                     // PROP end
  FORM ILBM                      // Absent size
    BODY [size] [image]
  ' END' [0]                     // FORM end
  FORM ACBM                      // Absent size
    BODY [size] [alt image]
  ' END' [0]                     // FORM end
  FORM 8SVX                      // Absent size
    VHDR [size] [header]
    BODY [size] [audio]
  ' END' [0]                     // FORM end
' END' [0]                       // LIST end
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Note: Wildcard PROP applies to all subsequent FORMs.

 

### 10.4 Typed CAT Example (Blobbed Mode)

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CAT [size] ILBM
  FORM [size] ILBM BODY [size] [frame1]
  FORM [size] ILBM BODY [size] [frame2]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Note: Non-blank type enforces matching.

 

### 10.5 Progressive LIST with Interleaved PROPs

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
LIST                     // Absent size, blank type
  PROP                   // Initial wildcard, absent size
    CMAP [size] [global palette]
  ' END' [0]             // PROP end
  FORM ILBM              // Absent size, uses initial PROP for CMAP
    BODY [size] [data]
  ' END' [0]             // FORM end
  PROP ILBM              // Interleaved update, absent size
    BMHD [size] [ILBM-specific override]
  ' END' [0]             // PROP end
  FORM ILBM              // Absent size, uses updated PROP for BMHD
    BODY [size] [data]
  ' END' [0]             // FORM end
  FORM 8SVX              // Absent size, sees CMAP, BMHD decoder doesn't pull them
    BODY [size] [data]
  ' END' [0]             // FORM end
' END' [0]               // LIST end
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

### 10.6 Sharded Chunk Example

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
BODY [size1] [part1]
'    ' [size2] [part2]
'    ' [size3] [part3]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

### 10.7 Directive in PROP (Progressive Mode)

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PROP ILBM   // Absent size
  BMHD [size] [big-endian header]
  ' IFF' [size] [switch to little-endian]
  CMAP [LE size] [palette size still BE. ILBM Format defined]
' END' [0]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

### 10.8 Roaming Directive in CAT (Progressive Mode)

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CAT           // Absent size, blank type
  ' IFF' [size] [little-endian]
  FORM ILBM   // Absent size
    BODY [LE size] [data endian unaffected]
  ' END' [0]
  FORM 8SVX   // Absent size
    BODY [LE size] [data endian unaffected]
  ' END' [0]
' END' [0]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

### 10.9 Progressive Streaming with Sharding

**Use Case**: Fragmented live video stream.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CAT  VDEO           // Absent size, specific type
  ' IFF' [size] [progressive + sharding + 64-bit]
  FORM  FRME        // Absent size
     VHDR  [size1] [part1]
    '    ' [size2] [part2]
     BODY  [size3] [pixels1]
    '    ' [size4] [pixels2]
    '    ' [size5] [pixels3]
  ' END' [0]
  FORM  FRME        // Absent size
    {next frame}
  ' END' [0]
' END' [0]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

 

10. Canonical Forms for Tags
----------------------------

 

To facilitate interoperability across variable tag lengths, IFF-2025 defines
canonical normalization rules. Parsers convert tags to a standardized form based
on their maximum supported length, using padding to align content.

 

### 10.1 Normalization Rules

-   **Data Tags**: Left-align content, right-pad with spaces to disallow leading
    spaces.

-   **Directive Tags**: Right-align content, left-pad with spaces to preserve
    leading spaces.

-   **Process**: pad to the maximum supported length.

-   **Comparison**: Always use the canonical form for matching and hashing,
    including for type tags (blank ' ' is canonicalized as all spaces).

 

### 10.2 ASCII Diagram (Padding and normalization examples):

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
4-byte Tags:
Data:     [FORM]
Directive:[ IFF]

8-byte Tags:
Data:     [FORM    ]
Directive:[     IFF]

16-byte Tags:
Data:     [FORM            ]
Directive:[             IFF]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

###  

**Benefits**:

-   Enables seamless reading of 4-byte files by 16-byte parsers.

-   Simplifies internal storage (e.g., single hash key per tag semantic).

-   Maintains distinction between data and directive types, including blank
    wildcards.

 

 

Appendix A: Credits and Contributions
-------------------------------------

 

This specification extends the original IFF-85 work.

Credits to the IFF-85 team as listed in section 7 of the original specification:

-   Bob "Kodiak" Burns, Commodore-Amiga

-   R. J. Mical, Commodore-Amiga

-   Jerry Morrison, Electronic Arts

-   Greg Riker, Electronic Arts

-   Steve Shaw, Electronic Arts

-   Barry Walsh, Commodore-Amiga

-   Oct, 1988 revision by Bryce Nesbitt, and Carolyn Scheppner, Commodore-Amiga

 

IFF-2025 Contributors:

-   Claudio Russo

-   Dario Russo

 

 

Appendix B: Extended Backus-Naur Form (EBNF) Grammar
----------------------------------------------------

 

Updated to reflect type tag restrictions and interleaved PROPs in LIST.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
; Root file (may start with IFF directive)
iff_file        = [iff_directive] top_level

; Top-level containers (one or more)
top_level       = (cat | form | list)+

; Core chunk (sizing variable per scope)
chunk           = data_property | directive

; DATA PROPERTIES (non-directive chunks)
data_property   = tag size data padding?

; DIRECTIVES (roaming, anywhere chunks allowed)
directive       = directive_tag size directive_data

; CONTAINERS (size present in blobbed, absent in progressive)
form            = "FORM" [size] form_type_tag form_content [end_directive]  
cat             = "CAT " [size] container_type_tag cat_content [end_directive]
list            = "LIST" [size] container_type_tag list_content [end_directive]
prop            = "PROP" [size] prop_type_tag prop_content [end_directive]

; CONTAINER CONTENT (allows roaming directives)
form_content    = (directive | data_property | nested_container)*
cat_content     = (directive | nested_container)*
list_content    = (directive | prop | nested_container)*
prop_content    = (directive | data_property)*

; Nested containers (recursive, excludes prop to prevent direct nesting in FORM/CAT)
nested_container = form | cat | list

; END Directive (REQUIRED in progressive)
end_directive   = " END" size (0)                   ; Size must be 0

; Types (variable length, endian-invariant)
tag             = {ascii} (4|8|16)                  ; Padded spaces
size            = integer (2|4|8)                   ; Signed/unsigned per flags
form_type_tag   = tag - blank_tag                   ; Non-blank for FORM
container_type_tag = tag                            ; Blank allowed for LIST/CAT
prop_type_tag   = tag                               ; Blank as wildcard for PROP
blank_tag       = "    "                            ; All spaces, length-dependent

; Directive Tags (space-prefixed)
directive_tag   = " IFF" | " END" | "    "

; Directive Data
directive_data  = iff_directive | end_data | shard_data
iff_directive   = version_byte revision_byte flags_8bytes
end_data        = 0                                 ; ' END' size=0
shard_data      = data                              ; '    ' continuation

; IFF Directive (fixed 10 bytes)
version_word    = 40                                ; 2025 epoch
revision_word   = 0..0xFFFF                         ; Minor rev
flags_8bytes    = 64bits                            

; Data (arbitrary)
data            = {byte}+

; Padding (even bytes)
padding         = (0 | 1 byte)                      ; Make total even

; Abstract (scope-dependent)
integer(n)      = n-bytes BE/LE signed/unsigned
64bits          = 8 bytes BE/LE
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

### C.1 Key Clarifications

| Rule       | Allows Roaming Directives? | Allows Blank Type? | Notes                                                                                   |
|------------|----------------------------|--------------------|-----------------------------------------------------------------------------------------|
| `form`     | ✅                          | ❌                  | Enforce specific type; allows data properties and nesting (FORM, CAT, LIST)             |
| `cat`      | ✅                          | ✅                  | Heterogeneous if blank; nesting (FORM, CAT, LIST); no direct PROP or data properties    |
| `list`     | ✅                          | ✅                  | Heterogeneous if blank; interleaved PROPs/nesting (FORM, CAT, LIST); no data properties |
| `prop`     | ✅                          | ✅ (wildcard)       | Flat data; updates properties for subsequent                                            |
| `iff_file` | ✅ Root `' IFF'`            | N/A                | root IFF configuration                                                                  |

 

**Examples**:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
; Invalid: Blank FORM type
FORM [size]      // Error: Non-blank required

; Valid: Interleaved PROP in LIST
LIST [size]     
  PROP [size]      CMAP ...
  FORM [size] ILBM ...
  PROP [size] ILBM BMHD ...  // Updates for next
  FORM [size] ILBM ...

; Roaming directive mid-FORM
FORM ILBM 
  BMHD 
  ... 
  ' IFF' [LE] 
  BODY 
  ... 
' END'
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

 

MIT License
-----------

Copyright (c) 2025 Claudio Russo and Dario Russo

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
