IFF-2025 Specification
======================

### Interchange File Format for Modern Computing

 

 

## 1. Introduction
------------------

IFF-2025 is a data container format that offers a flexible, extensible framework
for embedding and transporting diverse data structures, such as multimedia
content, AI models, archives, and custom formats. Unlike traditional formats
with rigid structures, IFF-2025 prioritizes forward compatibility, parsing
safety, and adaptability to modern computing environments. Its core principle
centers on self-describing chunks: each data segment is prefixed with an
identifier (tag) and length indicator (size), allowing parsers to safely skip
unrecognized or irrelevant content without disrupting the overall structure.

Originally created by Electronic Arts (EA) in 1985 for the Amiga platform as
Interchange File Format (IFF-85), it focused on multimedia interchange in
resource-constrained systems. IFF-85 introduced hierarchical nesting, shared
properties, and container types, though many advanced features went
underutilized, leading to simplified derivative formats. However, constraints
like fixed 32-bit sizes (limiting data to about 2 or 4 GB), mandatory big-endian
encoding, and lack of streaming support limited its modern adoption.

IFF-2025 evolves IFF-85 by retaining its foundational concepts while adding
enhancements to overcome these limitations. Key updates include variable-length
tags and sizes, configurable endianness, signed/unsigned integers, progressive
(streaming) modes, sharding for fragmented data, and scoped directives for
runtime configuration. These enable efficient management of large datasets,
real-time streaming, and heterogeneous content aggregation, suiting applications
in multimedia processing, AI data interchange, archival systems, and distributed
computing.

Backward compatibility with IFF-85 is preserved where possible: by default,
IFF-2025 follows IFF-85 rules (e.g., 4-byte uppercase ASCII tags, 32-bit
big-endian sizes, blobbed mode). Deviations occur via explicit directives,
allowing legacy parsers to handle compatible subsets without errors. This "power
with control" approach avoids parsing ambiguities or security risks, like buffer
overflows, through scoped limits and validation rules.

This specification details the format's structure, core components, parsing
models, configuration mechanisms, and implementation guidelines. Aimed at
developers building parsers, writers, validators, and tools, it includes
high-level pseudocode and examples but defers detailed internals (e.g., scope
management data structures) to reference implementations. The emphasis is on
normative rules, behavioral semantics, and interoperability requirements.

 

 

## 2. Summary of Evolution: From IFF-85 to IFF-2025
---------------------------------------------------

This section offers a concise overview of IFF-2025's heritage and advancements
for context.

 

### 2.1 IFF-85 Overview

IFF-85 featured fixed 4-byte uppercase ASCII tags, 32-bit big-endian sizes, and
even-byte padding for alignment. Its primary container types included FORM (for
typed single chunks), LIST (for grouping with shared properties), CAT (for
concatenating similar items), and PROP (for shared properties applicable to
subsequent items in CAT or LIST, but restricted to positions before FORMs).

Reserved tags encompassed FOR1 through FOR9, CAT1 through CAT9, LIS1 through
LIS9, and 'JJJJ', with chunk versioning achieved via last-letter overrides
(e.g., CMAP reserving CMA1 through CMA9). Standard LIST properties were
hardware-specific, such as OPGM (original program), OCPU (original CPU), OCMP
(original compiler), OSN (original serial number), and UNAM (user name).

Applications centered on Amiga multimedia, including ILBM (InterLeaved BitMap
images), 8SVX (8-bit sampled voice audio), SMUS (simple music), and professional
3D rendering software. Strengths lay in its self-describing structure, enabling
skipping of unknown chunks, and hierarchical nesting for complex data
organization. Limitations, however, included fixed size constraints that
hindered scalability, absence of native streaming support, big-endian encoding
amid endian debates, risks of uncontrolled deep nesting, reduced portability
from hardware-specific properties, and inflexible PROP placement.

 

### 2.2 Derivative Formats (e.g., RIFF)

Derivatives like Microsoft's Resource Interchange File Format (RIFF) adopted a
little-endian variant, simplifying the structure by eliminating CAT and PROP
containers and enforcing stricter nesting rules. RIFF found use in formats such
as WAV (audio), AVI (video), and WebP (images). These adaptations enhanced
simplicity for PC environments but introduced redundancy in large files (e.g.,
repeated headers), reduced flexibility for heterogeneous or shared data, and
created a fragmented legacy through the endian switch.

 

### 2.3 IFF-2025 Advancements

IFF-2025 restores IFF-85's flexibility while introducing modern controls. It
supports variable tags with configurable lengths of 4, 8, or 16 bytes, fully
case-sensitive (e.g., 'ILBM' ≠ 'ilbm') to enable namespaces and avoid
collisions. Sizes are variable at 16-bit, 32-bit, or 64-bit integers,
configurable as signed/unsigned and big-endian/little-endian.

Operating modes include blobbed (fully sized, default) for static files and
progressive (END-terminated) for streaming and append-only scenarios. Sharding
facilitates data continuation across fragments via filler directives, aiding
large or distributed data handling. Scoped directives, such as ' IFF' chunks,
allow runtime configuration with inheritance and guards for safety.

Previously reserved tags (e.g., FOR1-FOR9) are now available for custom use,
while hardware-specific LIST properties (OPGM, OCPU, etc.) and versioning via
chunk ID overrides are discontinued—versioning is now handled via directives.
Enhanced PROP handling permits multiple PROPs in LIST for layered overrides
(last-wins semantics); PROPs can appear anywhere in LIST, applying to subsequent
FORMs or nested containers, with no container nesting within PROPs to maintain
flatness.

Validation and safety features enforce container types, scoped limits to prevent
overflows, and directive guards against parent constraint violations. In
summary, IFF-2025 revives IFF-85's elegance, addresses RIFF's rigidity, and
equips the format for 2025-era challenges like petabyte-scale archives and
real-time AI model streaming.

 

 

## 3. Fundamental Types: Tags and Sizes
---------------------------------------

IFF-2025 relies on two primitives for self-description: tags (identifiers) and
sizes (length indicators). These are configurable via directives but default to
IFF-85-compatible settings for interoperability.

 

### 3.1 Tags

Tags represent chunk keys and literal keywords for container variants and types.
They consist of fixed-length byte sequences serving as unique identifiers for
chunks or directives, with configurable lengths of 4 bytes (default), 8 bytes,
or 16 bytes.

Encoding uses ASCII characters, fully case-sensitive, with shorter identifiers
padded with spaces ('    ') to the required length. Data tags are left-aligned
and right-padded (e.g., 'FORM' becomes 'FORM ' in 8-byte mode), while directive
tags are right-aligned and left-padded (e.g., ' IFF' becomes ' IFF' in 8-byte
mode).

Tag properties include endian-invariance, as byte order is unaffected by endianness
configurations (tags are read as raw byte sequences, not numeric types).
Canonical forms are normalized for comparison and hashing to ensure
interoperability across lengths (see Section 11). Comparisons are
lexicographical after canonicalization, prioritizing type then content; hashing
(e.g., FNV-1a) operates on the canonical form for dictionaries or stack frames.

 

### 3.2 Sizes

Sizes are integers indicating the subsequent data payload length, excluding tag
and size fields. Length options include 2 bytes (16-bit), 4 bytes (32-bit,
default), or 8 bytes (64-bit). Encoding supports big-endian (default) or
little-endian, and signed (default) or unsigned.

Maximum values depend on configuration (e.g., 64-bit unsigned supports up to 18
exabytes), though implementations may impose application-specific caps to
prevent resource exhaustion. Padding provides optional even-byte alignment after
data (default: enabled) and is configurable via directives.

 

 

## 4. Core Components: Containers and Chunks
--------------------------------------------

IFF-2025 data consists of components categorized as containers (composite
structures embedding others) or chunks (atomic units). The term "chunk" derives
from IFF-85 and encompasses both data properties and directives in IFF-2025.

The general chunk structure is [Tag] [Size] [Byte Data] [Optional Padding],
where data properties serve as atomic holders for user-defined data, and
directives act as parser control instructions. The general container structure
is [(Variant) Tag] [Size (required in blobbed mode, absent in progressive mode)]
[(Type) Tag] [Nested Sub-Components or Chunks] [Optional Padding]. Containers
support nesting, with directives at any level for dynamic configuration. In
progressive mode, the absence of a size field avoids back-patching, with
termination handled via ' END' directives; parsers detect mode via scope flags
and adjust expectations accordingly.

 

### 4.1 Chunks in Detail

Chunks form the atomic building blocks, divided into data properties and
directives.

 

#### 4.1.1 Data Properties

These have a non-directive tag + Size + Arbitrary byte data + Optional padding.
Their purpose is to store metadata, content, or custom payloads (e.g., 'BMHD'
for bitmap headers, 'BODY' for raw pixel or audio data). Constraints limit them
to FORM or PROP containers; they are not permitted directly in LIST or CAT.

 

#### 4.1.2 Directives

IFF-85 forbids type IDs with leading spaces before printable characters, so
directives start with spaces. Their structure is Directive tag + Size +
Directive-specific data (or END-terminated in progressive modes).

Currently defined directive tags include ' IFF' for configuration header scope
updates (detailed in Section 8), ' END' for container termination in progressive
mode (size must be 0, no data), '    ' (all spaces, length-dependent) for
filler (padding) or shard (data continuation) based on structuring flags and 
metadata directives like ' ver'/' rev' to optionally indicate a FORM version/revision,
' chk'...' sum' to start and complete a crc/checksum/integrity validation span.
Directives can appear within containers and are evaluated in the current scope,
enabling fine-grained control without global side effects.

 

### 4.2 Containers in Detail

Containers organize data hierarchically, with a variant tag indicating type, a
size field (in blobbed mode only), and a type tag for validation.

Type tag semantics vary by container: For FORM, it must be specific and
non-blank (e.g., 'ILBM'); blank '    ' is not permitted, as composition uses
nesting. For LIST and CAT, a blank '    ' skips type validation for
heterogeneous sub-components, while a specific tag (e.g., 'ILBM') requires
matching sub-FORMs, with validation inherited through nesting. For PROP, a blank
'    ' acts as a wildcard, applying properties to any FORM in the enclosing
LIST; a specific tag applies only to matching types.

This ensures type safety for single-unit FORM containers while providing
flexibility in LIST, CAT, and PROP wildcards, replacing discontinued base LIST
properties.

 

#### 4.2.1 FORM Container

The structure is 'FORM' variant tag + [Size (blobbed only)] + Type tag
(non-blank) + Sequence of sub-components (data properties, directives, or nested
containers: FORM, CAT, LIST). It encapsulates typed related data (e.g., an image
with headers and body), achieving composition via nesting.

IFF-2025 enhancements include progressive mode for streaming and directives for
modifying parsing within the FORM. Validation requires a non-blank type tag;
parsers reject blanks for FORM. No direct PROPs are allowed (use LIST for shared
properties), but it supports heterogeneous trees via nesting.

 

#### 4.2.2 CAT Container

The structure is 'CAT ' variant tag + [Size (blobbed only)] + Type tag +
Sequence of nested containers (FORM, CAT, LIST) interspersed with directives. It
concatenates items—heterogeneous with a blank type or homogeneous with a
specific type—supporting nesting for complex aggregations.

IFF-2025 enhancements allow directives to intersperse containers for dynamic
adjustments (e.g., endianness switches) and LIST nesting for indirect shared
properties. Validation mandates matching sub-FORMs in strict mode for non-blank
types; blanks allow any. No direct data properties or PROPs are permitted.

 

#### 4.2.3 LIST and PROP Containers

The LIST structure is 'LIST' variant tag + [Size (blobbed only)] + Type tag +
Interleaved sequence of PROPs, directives, and nested containers (FORMs, CATs,
LISTs). Multiple PROPs enable layered overrides (last wins), positionable
anywhere to update subsequent components. Its purpose is grouping heterogeneous
items with phased defaults (e.g., mixed ILBM images and 8SVX audio), with blank
types permitting any sub-FORMs. No direct data properties are allowed; these
must be wrapped in FORM. Validation requires matching sub-FORMs in strict mode
for non-blank types; blanks allow any.

The PROP structure is 'PROP' variant tag + [Size (blobbed only)] + Type tag +
Flat sequence of data properties (interspersed with directives). Constraints
prohibit nested containers, with directives scoped locally. Its purpose is
defining or updating shared properties for subsequent data in the enclosing
LIST, with blank types as wildcards for any FORM or specific tags for targeted
application. In heterogeneous LISTs (blank type), wildcard PROPs set global
defaults, while type-specific ones override matches. PROPs employ pull
semantics: decoders request properties explicitly, avoiding unrequested data
injection.

 

**ASCII Diagram (LIST with Interleaved PROPs)**:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+----------------------------------+
| LIST |  [size (blobbed)]  |      | // Blank type: heterogeneous
+----------------------------------+
 +--------------------------------+
 | PROP | [size (blobbed)] |      |  // Initial wildcard PROP
 +--------------------------------+
  +------------------------------+
  | CMAP | size | global palette |
  +------------------------------+
 +--------------------------------+
 | FORM | [size (blobbed)] | ILBM |  // Uses initial PROP
 +--------------------------------+
  +------------------------------+
  | BODY | [size] | [image data] |
  +------------------------------+
 +--------------------------------+
 | PROP | [size (blobbed)] | ILBM |  // Interleaved override for ILBM
 +--------------------------------+
  +------------------------------+
  | BMHD | size | updated header |
  +------------------------------+
 +--------------------------------+
 | FORM | [size (blobbed)] | ILBM |  // Uses updated PROP
 +--------------------------------+
  +------------------------------+
  | BODY | [size] | [image data] |
  +------------------------------+
 +--------------------------------+
 | FORM | [size (blobbed)] | 8SVX |  // Could access PROP but 8SVX doesn't need
 +--------------------------------+
  +------------------------------+
  | BODY | [size] | [audio data] |
  +------------------------------+
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

 

## 5. Scope Management and metadata directives
----------------------------------------------

Scopes manage configuration states and resource limits via a stack or dictionary
(non-normative; implementations vary). The scope stack is pushed on container
entry and popped on exit.

Each scope entry contains configuration flags (from directives), a remaining
byte limit (derived from size or inherited from parent), type validation rules
(from container type tag), and a shared property map (updated by PROPs).
Inheritance rules pass parent flags, limits, validation, and maps to children;
updates affect only the current scope and descendants.

Guards ensure safety by preventing changes that violate parent constraints
(e.g., exceeding parent bytes), with validation enforcing FORM specificity and
PROP applicability. For PROP-specific scopes, properties merge into the current
map with overrides, applying to subsequent LIST components for phased updates.
No fixed depth limit is specified; parsers should handle reasonable depths and
guard against excessive nesting.

Further protection is enabled via metadata controlling directives, allowing an 
optional finegrained control over versioned file formats and data integrity.

### 5.1 ' VER' and ' REV': file format version specifiers

These two directives allow file formats to evolve over time, specifying a version 
and revision that encoders/decoders must support to parse chunks appropriately. 
Their formats are similar: [' VER', size, size-number of bytes] and 
[' REV', size, size-number of bytes]. As per directive rules, they are not required 
to be the first element inside a FORM, but that is typically the optimal placement. 
The byte content is expected to follow a data format specified by the application.

### 5.2 ' CHK' and ' SUM': Span-Based Integrity Checks

The ' CHK' and ' SUM' directives define starting and ending points for data integrity checks. 
Multiple ' CHK' instances can appear throughout a single file, with matching ' SUM' 
assigned in LIFO order. They are tracked individually, so concurrent ' CHK' points 
are discouraged to avoid complexity.

' CHK' has the structure [' CHK', size, algorithm-identifier-bytes]. 
' SUM' follows [' SUM', size, checksum-bytes]. 
An unmatched ' CHK'/' SUM' pair constitutes a validation failure. 
Parser implementors may choose to ignore or enforce (recommended) integrity validation.

**Defined Algorithms**:

| Algorithm     | Identifier     | Output Size | Use Case                  |
|---------------|----------------|-------------|---------------------------|
| LRC-ISO-1155  | "LRC-ISO-1155" | 8 bits      | Small devices             |
| RFC-1071      | "RFC-1071"    | 16 bits     | Lightweight checksums     |
| CRC-32C       | "CRC-32C"     | 32 bits     | General purpose           |
| CRC64-ECMA    | "CRC64-ECMA"  | 64 bits     | High integrity, large data|

**Example**:
```
FORM ILBM [size]
 ' CHK' [size] "CRC-32C"    // Start checksum span
  BODY  [size] [pixels]     // Checksummed data
 ' SUM' [size] [0xA1B2C3D4] // 32-bit CRC-32C
```

 

 

## 6. Sharding
--------------

Sharding fragments large data properties for partial decoding during parsing,
enhancing streaming support.

 

### 6.1 Sharding and Filler Directives

The '    ' directive tag (all spaces, length-dependent, e.g., '    ' for 4
bytes) operates in filler mode (Structuring Bit 1 = 0, default), where it is
skipped as padding with no data impact, or sharding mode (Structuring Bit 1 =
1), where it appends to the preceding chunk for seamless continuation (e.g.,
network fragments).

Constraints require it to follow a valid chunk; it is invalid as the first
component or after container closure. It remains compatible with both blobbed
and progressive parsing modes.

 

 

## 7. Parsing Models
--------------------

As a superset of IFF-85, IFF-2025 allows full fallback to legacy mode. Files or
streams starting with root containers (CAT/LIST/FORM) imply clean IFF-85
parsing. See Section 9 for details.

IFF-85 mode can activate via directives, at root or locally. Once activated,
enhancements are unavailable, with effects ending at scope closure if switched
mid-container.

 

 

## 8. Configuration Directive: ' IFF'
-------------------------------------

The ' IFF' directive enables scoped parsing rule modifications for controlled
extensibility. Its structure is ' IFF' tag + Size + Version (2 bytes) + Revision
(2 bytes) + Flags (8 bytes).

The version field is fixed at 40 (2025 - 1985 = 40). The revision field starts
at 0 for minor patches. Flags form a 64-bit bitfield. Defaults match IFF-85
(32-bit big-endian signed sizes, 4-byte tags, blobbed mode, padding enabled).
Application guards reject changes exceeding parent limits or invalidating
states; effects are immediate for subsequent reads but do not alter fixed
container type semantics.

 

**ASCII Diagram**:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+----------+----------+------------+--------+--------------------+
| ' IFF'   | Size     | Version=40 | Rev=0  | Flags (8 bytes)    |
+----------+----------+------------+--------+--------------------+
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

### 8.1 Version Field

This identifies the major specification version, enabling opt-in for features
(see Section 7). Enumerated values include 0 for legacy IFF-85 mode (enforcing
constraints at root, with no further directives) and 40 for IFF-2025 mode
(enabling extensions like ' END' and sharding). It is not applicable by default
and must be explicitly set. IFF-85 parsers reject values greater than 0;
IFF-2025 parsers support at least 40, with no further values defined.

 

### 8.2 Revision Field

Currently unused.

 

### 8.3 Flags Bitfield

Bytes 4-11 (64 bits) form a big-endian bitfield, grouped into 8-bit sections.
Defaults match IFF-85, with scoped changes (immediate application, reverting on
scope exit; see Section 5).

The groups are: - Sizing (Bits 0-7): Controls size field length, from 16-bit for
embedded systems to 64-bit for large data. - Tag Sizing (Bits 8-15): Longer tags
reduce namespace collision risks. - Operating (Bits 16-23): Progressive mode
requires ' END' for containers. - Encoding (Bits 24-31): Reserved for compressed
payloads. - Typing (Bits 32-39): Unsigned for maximum range; little-endian
supported. - Structuring (Bits 40-47): No-padding for compact streams; sharding
for lower latency. - Reserved (Bits 48-63): For future use; unused in V40.

 

**Bit Layout ASCII Diagram**:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Sizing block
------------
00000000 : Base IFF 85, 32 bit sizes
00000001 : 64 bit sizes
11111111 : 16 bit sizes

Tag Sizing block
----------------
00000000 : Base IFF 85 mode, 4 bytes tag sizes
00000001 : 8 bytes tag sizes
00000002 : 16 bytes tag sizes

Operating modes block
---------------------
00000000 : Base IFF 85, Blobbed mode
00000001 : Progressive mode

Encoding modes block
--------------------
00000000 : Base IFF 85 mode, BASE256 (raw binary)

Typing Flags block (Affecting sizes only)
-----------------------------------------
00000000 : Base IFF 85 mode, Big Endian and Signed
00000001 : Switch to unsigned 
00000010 : Switch to little endian

Structuring Flags block
-----------------------
00000000 : Base IFF 85 mode, padding on and blank chunk type skipped
00000001 : Disable padding byte
00000010 : Enable sharding via blank chunk type
00000100 : Enforce CAT/LIST declared type vs contained FORM type validation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

#### 8.3.1 Blobbed Mode Notes

In blobbed mode, all components include explicit sizes; parsing reads the tag,
size, then exactly 'size' bytes of data or sub-components. Validation tracks
consumed bytes against the declared size, erroring on overruns or underruns.
Padding applies post-data for alignment (configurable). Use cases focus on
static files with known lengths upfront.

 

#### 8.3.2 Progressive Mode Notes

In progressive mode, containers lack sizes and terminate via ' END' directives,
with parsers detecting absence based on flags. Its purpose is enabling streaming
and append-only workflows without precomputing lengths. Bounding uses parent
scope remaining bytes (root may be unbounded, but parsers can impose caps).
Validation requires matching ' END' for open containers, with dynamic type
checks as sub-components appear. Padding applies post-data (configurable). Use
cases suit fragmented streams, where shards enable progressive decoding.

 

 

## 9. Parser Bootstrapping Notes
--------------------------------

For compatibility, parsers bootstrap in pseudo IFF-85 mode (IFF-2025 with
extensions off), equivalent to an ' IFF' directive of
[0x0028][0x0000][0x0000000000000000]. This upgrades to clean IFF-85
[0x0000][0x0000][0x0000000000000000] if the first tag is CAT/LIST/FORM, or
overrides via a proper ' IFF'.

A root ' IFF' sets global scope, with blobbed mode imposing file length limits.

 

### 9.1 Example Effects

 

#### 9.1.1 Clean IFF-85 via IFF Directive

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 IFF [size] {[0][0][0]}       // Clean IFF 85 start via explicit switch
FORM [size] ANIM
  BMHD [size] [header]
  CMAP [size] [palette]
   IFF { .. } <----------------- ERROR, invalid TAG
  BODY [size] [pixels]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

#### 9.1.2 IFF-85 Compatible Settings via IFF Directive

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 IFF [size] {[40][0][0]}      // IFF 85 alike configuration
FORM [size] ANIM              // Size is setting a boundary. Even switching to
  BMHD [size] [header]        //  64 bits, this boundary cannot be exceeded
  CMAP [size] [palette]
   IFF { .. } <----------------- Further mode switch possible with limitations
  BODY [size] [pixels]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

#### 9.1.3 Clean IFF-85 via First Tag Rule

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
FORM [size] ANIM              // First Tag is a FORM, promoting config to IFF 85
  BMHD [size] [header]
  CMAP [size] [palette]
   IFF { .. } <----------------- ERROR, invalid TAG
  BODY [size] [pixels]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

#### 9.1.4 Temporary IFF-85 Compatible Settings in a Scope

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 IFF [size] {[40][0][0]}      // IFF 85 alike configuration
CAT  [size] AMIM 
  FORM [size] ANIM            
    BMHD [size] [header]      
    CMAP [size] [palette]
     IFF [size] {[0][0][0]} <--- Locks to IFF 85, no further directives allowed
    BODY [size] [pixels]
  FORM [size] ANIM          <--- A new FORM constitutes a new scope. Inheriting 
    BMHD [size] [header]           the parent configuration [40][0][0]
     IFF [size] {[40][0][0]} <-- Further mode switch possible with limitations
    CMAP [size] [palette]
     IFF [size] {[40][0][0]} <-- Further mode switch possible with limitations
    BODY [size] [pixels]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

#### 9.1.5 Implicit IFF-85 Mode Locking

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CAT  [size] AMIM              // First Tag is a FORM, promoting config to IFF 85
  FORM [size] ANIM          <--- A new FORM constitutes a new scope. Inheriting 
    BMHD [size] [header]           the parent configuration as [0][0][0]
    CMAP [size] [palette]          still no directives allowed anymore 
    BODY [size] [pixels]
  FORM [size] ANIM          
    BMHD [size] [header]           
    CMAP [size] [palette]
    BODY [size] [pixels]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

 

## 10. Illustrative Diagrams and Examples
-----------------------------------------

This section uses visuals and examples to clarify concepts, reflecting updated
type tags and interleaved PROPs.

 

### 10.1 Basic Chunk Diagram

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
+------+------+------+
| TAG  | SIZE | DATA |
+------+------+------+
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

### 10.2 Nested FORM Example (Blobbed Mode)

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
FORM [size] ANIM
  FORM [size] ILBM
    BMHD [size] [header]
    CMAP [size] [palette]
    BODY [size] [pixels]
  FORM [size] ILBM
    BMHD [size] [header]
    CMAP [size] [palette]
    BODY [size] [pixels]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Note: No blank type for FORM; nesting provides composition.

 

### 10.3 Heterogeneous LIST Example (Progressive Mode)

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
LIST                             // Absent size, type='    ' (heterogeneous)
  PROP                           // Wildcard, absent size
    CMAP [size] [shared palette]
  ' END' [0]                     // PROP end
  FORM ILBM                      // Absent size
    BODY [size] [image]
  ' END' [0]                     // FORM end
  FORM ACBM                      // Absent size
    BODY [size] [alt image]
  ' END' [0]                     // FORM end
  FORM 8SVX                      // Absent size
    VHDR [size] [header]
    BODY [size] [audio]
  ' END' [0]                     // FORM end
' END' [0]                       // LIST end
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Note: Wildcard PROP applies to all subsequent FORMs.

 

### 10.4 Typed CAT Example (Blobbed Mode)

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CAT [size] ILBM
  FORM [size] ILBM BODY [size] [frame1]
  FORM [size] ILBM BODY [size] [frame2]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Note: Non-blank type enforces matching.

 

### 10.5 Progressive LIST with Interleaved PROPs

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
LIST                     // Absent size, blank type
  PROP                   // Initial wildcard, absent size
    CMAP [size] [global palette]
  ' END' [0]             // PROP end
  FORM ILBM              // Absent size, uses initial PROP for CMAP
    BODY [size] [data]
  ' END' [0]             // FORM end
  PROP ILBM              // Interleaved update, absent size
    BMHD [size] [ILBM-specific override]
  ' END' [0]             // PROP end
  FORM ILBM              // Absent size, uses updated PROP for BMHD
    BODY [size] [data]
  ' END' [0]             // FORM end
  FORM 8SVX              // Absent size, sees CMAP, BMHD decoder doesn't pull them
    BODY [size] [data]
  ' END' [0]             // FORM end
' END' [0]               // LIST end
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

### 10.6 Sharded Chunk Example

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
BODY [size1] [part1]
'    ' [size2] [part2]
'    ' [size3] [part3]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

### 10.7 Directive in PROP (Progressive Mode)

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PROP ILBM   // Absent size
  BMHD [size] [big-endian header]
  ' IFF' [size] [switch to little-endian]
  CMAP [LE size] [palette size still BE. ILBM Format defined]
' END' [0]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

### 10.8 Roaming Directive in CAT (Progressive Mode)

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CAT           // Absent size, blank type
  ' IFF' [size] [little-endian]
  FORM ILBM   // Absent size
    BODY [LE size] [data endian unaffected]
  ' END' [0]
  FORM 8SVX   // Absent size
    BODY [LE size] [data endian unaffected]
  ' END' [0]
' END' [0]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

### 10.9 Progressive Streaming with Sharding

**Use Case**: Fragmented live video stream.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
CAT  VDEO           // Absent size, specific type
  ' IFF' [size] [progressive + sharding + 64-bit]
  FORM  FRME        // Absent size
     VHDR  [size1] [part1]
    '    ' [size2] [part2]
     BODY  [size3] [pixels1]
    '    ' [size4] [pixels2]
    '    ' [size5] [pixels3]
  ' END' [0]
  FORM  FRME        // Absent size
    {next frame}
  ' END' [0]
' END' [0]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

 

## 11. Canonical Forms for Tags
-------------------------------

For interoperability across tag lengths, IFF-2025 defines normalization rules.
Parsers convert tags to a standardized form based on the maximum supported
length, using padding to align content.

 

### 11.1 Normalization Rules

Data tags are left-aligned and right-padded with spaces (disallowing leading
spaces). Directive tags are right-aligned and left-padded with spaces
(preserving leading spaces). The process pads to the maximum supported length.
Comparisons always use the canonical form for matching and hashing, including
for blank '    ' (all spaces).

 

### 11.2 ASCII Diagram (Padding and Normalization Examples):

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
4-byte Tags:
Data:     [FORM]
Directive:[ IFF]

8-byte Tags:
Data:     [FORM    ]
Directive:[     IFF]

16-byte Tags:
Data:     [FORM            ]
Directive:[             IFF]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

**Benefits**:

Enables 16-byte parsers to read 4-byte files seamlessly, simplifies internal
storage (e.g., single hash key per semantic), and maintains distinction between
data and directive types, including blank wildcards.

 

 

## Appendix A: Credits and Contributions
----------------------------------------

This specification extends IFF-85.

Credits to the IFF-85 team per the original Section 7:

-   Bob "Kodiak" Burns, Commodore-Amiga

-   R. J. Mical, Commodore-Amiga

-   Jerry Morrison, Electronic Arts

-   Greg Riker, Electronic Arts

-   Steve Shaw, Electronic Arts

-   Barry Walsh, Commodore-Amiga

-   October 1988 revision by Bryce Nesbitt and Carolyn Scheppner,
    Commodore-Amiga

 

IFF-2025 Contributors:

-   Claudio Russo

-   Dario Russo

 

 

## Appendix B: Extended Backus-Naur Form (EBNF) Grammar
-------------------------------------------------------

Updated for type tag restrictions and interleaved PROPs in LIST.

 

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
; Root file (may start with IFF directive)
iff_file        = [iff_directive] top_level

; Top-level containers (one or more)
top_level       = (cat | form | list)+

; Core chunk (sizing variable per scope)
chunk           = data_property | directive

; DATA PROPERTIES (non-directive chunks)
data_property   = tag size data padding?

; DIRECTIVES (roaming, anywhere chunks allowed)
directive       = directive_tag size directive_data

; CONTAINERS (size present in blobbed, absent in progressive)
form            = "FORM" [size] form_type_tag form_content [end_directive]  
cat             = "CAT " [size] container_type_tag cat_content [end_directive]
list            = "LIST" [size] container_type_tag list_content [end_directive]
prop            = "PROP" [size] prop_type_tag prop_content [end_directive]

; CONTAINER CONTENT (allows roaming directives)
form_content    = (directive | data_property | nested_container)*
cat_content     = (directive | nested_container)*
list_content    = (directive | prop | nested_container)*
prop_content    = (directive | data_property)*

; Nested containers (recursive, excludes prop to prevent direct nesting in FORM/CAT)
nested_container = form | cat | list

; END Directive (REQUIRED in progressive)
end_directive   = " END" size (0)                   ; Size must be 0

; Types (variable length, endian-invariant)
tag             = {ascii} (4|8|16)                  ; Padded spaces
size            = integer (2|4|8)                   ; Signed/unsigned per flags
form_type_tag   = tag - blank_tag                   ; Non-blank for FORM
container_type_tag = tag                            ; Blank allowed for LIST/CAT
prop_type_tag   = tag                               ; Blank as wildcard for PROP
blank_tag       = "    "                            ; All spaces, length-dependent

; Directive Tags (space-prefixed)
directive_tag   = " IFF" | " END" | "    " | " VER" | " REV" | " CHK" | " SUM"

; Directive Data
directive_data  = iff_directive | end_data | shard_data | ver_data | rev_data | chk_data | sum_data
iff_directive   = version_word revision_word flags_8bytes
end_data        = 0                                 ; ' END' size=0
shard_data      = data                              ; '    ' continuation
ver_data        = data
rev_data        = data 
chd_data        = data 
sum_data        = data 

; IFF Directive 
version_word    = 40                                ; 2025 epoch
revision_word   = 0..0xFFFF                         ; Minor rev
flags_8bytes    = 64bits                            

; Data (arbitrary)
data            = {byte}+

; Padding (even bytes)
padding         = (0 | 1 byte)                      ; Make total even

; Abstract (scope-dependent)
integer(n)      = n-bytes BE/LE signed/unsigned
64bits          = 8 bytes BE/LE
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

### Appendix B.1 Key Clarifications

| Rule       | Allows Roaming Directives? | Allows Blank Type? | Notes                                                                                   |
|------------|----------------------------|--------------------|-----------------------------------------------------------------------------------------|
| `form`     | ✅                          | ❌                  | Enforce specific type; allows data properties and nesting (FORM, CAT, LIST)             |
| `cat`      | ✅                          | ✅                  | Heterogeneous if blank; nesting (FORM, CAT, LIST); no direct PROP or data properties    |
| `list`     | ✅                          | ✅                  | Heterogeneous if blank; interleaved PROPs/nesting (FORM, CAT, LIST); no data properties |
| `prop`     | ✅                          | ✅ (wildcard)       | Flat data; updates properties for subsequent                                            |
| `iff_file` | ✅ Root `' IFF'`            | N/A                | root IFF configuration                                                                  |

 

**Examples**:

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
; Invalid: Blank FORM type
FORM [size]      // Error: Non-blank required

; Valid: Interleaved PROP in LIST
LIST [size]     
  PROP [size]      CMAP ...
  FORM [size] ILBM ...
  PROP [size] ILBM BMHD ...  // Updates for next
  FORM [size] ILBM ...

; Roaming directive mid-FORM
FORM ILBM 
  BMHD 
  ... 
  ' IFF' [LE] 
  BODY 
  ... 
' END'
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

 

 

## MIT License
--------------

Copyright (c) 2025 Claudio Russo and Dario Russo

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
